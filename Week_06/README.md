## 动态规划(Dynamic Programming)
- 将复杂问题分解成简单的子问题
- 分治 + 最优字结构
### 关键点
- 动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）
- 共性：找到重复子问题
- 差异性：最优子结构、中途可以淘汰次优解

## 例题

### [64] 最小路径和(minPathSum)
#### 解题思路DP
- 重复性（分治）：由于只能向下或者向右移动，所以求到右下角的最小路径dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; i/j都可能为0，需要考虑越界情况
- 定义状态数组：dp[i][j]
- DP方程:
  - i === 0 && j !== 0: dp[i][j] = dp[i][j - 1] + grid[i][j]
  - i !== 0 && j === 0: dp[i][j] = dp[i - 1][j] + grid[i][j]
  - i !== 0 && j !== 0: dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
  - i === 0 && j === 0: dp[i][j] = grid[i][j]

## [647] 回文子串(countSubstrings)
#### 解题思路DP
- 一个字符串是回文串，那首尾相同且剩余子串也是回文串，所以转换成子问题就是，剩余子串是否是回文串。
- dp[j]
- 几种情况：
  - 单个字符
  - 两个字符，且两个字符相同
  - 大于两个字符，且首尾相同，剩余子串也是回文串